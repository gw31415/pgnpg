---
import Main from "../../../layouts/Main.astro";
---
<Fragment slot="head">
	<link rel="canonical" href="https://pgn.amas.dev/profile/" />
	<script is:inline src="https://cdn.jsdelivr.net/npm/js-circle-progress/dist/circle-progress.min.js" type="module"></script>
</Fragment>

<Main>
	<header style="display:flex;justify-content:space-between;align-items:center">
		<div id="title" class="typing" style="font-size:2rem">@</div>
		<div id="updatedat" style="text-align:right"></div>
	</header>
	<main>
		<section style="height:calc(100vh - 6rem);margin-bottom:3rem;display:flex;flex-direction:column;align-items:center;justify-content:space-evenly">
			<h1 id="level" style="opacity:0;transition:opacity 1s;font-size:3.5rem;font-family:'Jersey 10',monospace"></h1>
			<div><circle-progress text-format="vertical"></circle-progress></div>
		</section>
		<section id="daily-chart" style="height:150vh;width:100vw;padding:.5rem">
			<h2>Daily PIX</h2>
			<canvas></canvas>
		</section>
	</main>
	<div id="errmsg" class="typing">Loading...</div>
</Main>

<style lang="scss">
	circle-progress::part(base) {
		height: 60vmin;
		width: 60vmin;
	}
	circle-progress::part(value) {
		stroke-width: 3px;
		stroke: white;
		stroke-linecap: round;
	}
	circle-progress::part(circle) {
		stroke-width: 6px;
		stroke: #888;
	}
	circle-progress::part(text) {
		fill: #888;
		font-family: 'Orbitron', sans-serif;
	}

	.rainbow {
		background: linear-gradient(to-right, #FF0000, #FF7F00, #FFFF00, #00FF00, #0000FF, #4B0082, #8B00FF);
		background: -webkit-linear-gradient(left, #FF0000, #FF7F00, #FFFF00, #00FF00, #0000FF, #4B0082, #8B00FF);
		background: -o-linear-gradient(right, #FF0000, #FF7F00, #FFFF00, #00FF00, #0000FF, #4B0082, #8B00FF);
		background: -moz-linear-gradient(right, #FF0000, #FF7F00, #FFFF00, #00FF00, #0000FF, #4B0082, #8B00FF);
		-webkit-background-clip: text;
		background-clip: text;
		-webkit-text-fill-color: transparent;
		text-fill-color: transparent;
	}

	@-webkit-keyframes svg {
		0% {
			stroke-dashoffset: 2000;
			fill: transparent;
		}

		40% {
			stroke-dashoffset: 2000;
			fill: transparent;
		}

		50% {
			fill: transparent;
		}

		100% {
			stroke-dashoffset: 0;
			fill: #888;
		}
	}

	header, main {
		transition: opacity .2s;
	}

	header {
		padding: .5rem;
	}

	body {
		display: flex;
		justify-content: center;
		align-items: center;
		header, main {
			opacity: 0;
			width: 0;
			height: 0;
			overflow: hidden;
		}
		#errmsg {
			display: block; // wf-activeでも無効化しない
		}
	}

	html.wf-active.ready {
		// wf-activeかつreadyなら非表示
		body {
			display: block;
		}
		header, main {
			opacity: 1;
			width: 100%;
			height: auto;
		}
		#errmsg {
			display: none; // wf-activeかつreadyなら非表示
		}
	}
</style>

<script>
import type {PgnLevel} from "../../../types";
import type  UserProfile from "../../../types";

import WebFont from "webfontloader";

interface Color<T extends PgnLevel = PgnLevel> {
	level: T,
	color: T extends "GrandMaster" ? undefined : string,
	min:  number,
}

const colors: Color[] = [
	{ level: "Iron", color: "#ac9393", min: 0 },
	{ level: "Bronze", color: "#aa4400", min: 500 },
	{ level: "Silver", color: "#a7a7a7", min: 1000 },
	{ level: "Gold", color: "#c8ab37", min: 2500 },
	{ level: "Platinum", color: "black", min: 5000 },
	{ level: "Diamond", color: "#00aad4", min: 10000 },
	{ level: "Master", color: "#6A0DAD", min: 20000 },
	{ level: "GrandMaster", color: undefined, min: 35000 },
]

function enableTyping(e: Element, msg?: string) {
	const el = e as HTMLElement;
	if (msg) errmsg.textContent = msg;
	const len = `${el.textContent}`.length + 1;
	el.style.animation = `typing ${Math.min(1, 0.1 * len)}s steps(${len}), blink .4s step-end infinite alternate`;
	el.style.width = `${len}ch`;
	el.addEventListener("animationend", () => {
		el.style.animation = "none";
		el.style.borderRight = "none";
	});
}
const errmsg = document.getElementById("errmsg")!;
enableTyping(errmsg, "Loading...");

const data: UserProfile = await fetch("data.json").then((res) => {
	if (!res.ok) {
		enableTyping(errmsg, "User Not Found.");
		errmsg.style.display = "block";
		return undefined;
	}
	return res.json();
});

if (data === undefined) {
	document.title ="Not Found - PGN Profile";
	throw new Error("User Not Found.");
} else {
	document.title = `@${data.user.pgrit_id} - PGN Profile`;
}

WebFont.load({
	google: {
		families: ['Jersey 10'],
		text: "IronBronzeSilverGoldPlatinumDiamondMasterGrandMaster",
	}
});
WebFont.load({
	google: {
		families: ['Orbitron'],
		text: "0123456789%",
	}
});

async function start() {
	document.getElementById("title")!.textContent = '@' + data.user.pgrit_id;
	document.getElementById("updatedat")!.textContent = new Date(data.pgn.updated_at).toLocaleString();

	document.querySelectorAll(".typing").forEach((e) => enableTyping(e));

	const circle = document.getElementsByTagName("circle-progress")[0]! as HTMLElement;
	if (data.pgn.level === "GrandMaster") {
		circle.setAttribute("value","100");
		circle.setAttribute("max","100");
		circle.setAttribute("text-format", "percent");
	}else {
		circle.setAttribute("value", `${data.pgn.on_level}`);
		circle.setAttribute("max", `${data.pgn.level_length}`);
	}

	const level = document.getElementById("level")!;
	const color = colors.find((c) => c.level === data.pgn.level)!;
	if (color.color) {
		level.style.color = color.color;
	} else {
		level.classList.add("rainbow");
	}
	level.style.opacity = "1";
	level.textContent = `${data.pgn.level}`;

	document.getElementsByTagName("html")[0]!.classList.add("ready");

	const daily = Object.entries(data.pgn.daily).sort((a, b) => -a[0].localeCompare(b[0]));

	const dailyChart = document.querySelector("#daily-chart canvas") as HTMLCanvasElement;
	dailyChart.height = document.getElementById("daily-chart")!.offsetHeight;
	dailyChart.width = document.getElementById("daily-chart")!.offsetWidth;

	const chartjs = await import("chart.js/auto");
	new chartjs.Chart(dailyChart, {
		type: "bar",
		data: {
			labels: daily.map(([k]) => k.slice(5).replace(/^0/g, "").replace(/-0/g, "-").replace("-", "/")),
			datasets: [{
				data: daily.map(([_, v]) => v),
				backgroundColor: daily.map(([_, v]) => colors
					.toSorted((a, b)=> b.min - a.min)
					.find((c) => c.min <= v * 28)?.color ?? "#ff5555"),
				borderWidth: 0,
			}]
		},
		options: {
			indexAxis: 'y',
			plugins: {
				legend: {
					display: false,
				},
			},
			scales: {
				y: {
					beginAtZero: true,
				},
			},
		},
	});
}
if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', start); else start();
</script>
